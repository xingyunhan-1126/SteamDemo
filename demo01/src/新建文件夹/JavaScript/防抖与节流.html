<html>
    <script>
        /*防抖  如果短时间内大量触发同一事件，只会执行一次函数。**/
        function debounce(fn, delay){       //fn是防抖的函数
            let timeId = null;               //用一个闭包来实现
            return function(fn, delay){
                if(timeId){
                    clearTimeout(timeId); //当debounce再次被调用，会去看此时time是否存在（是否有一个fn正在等待时间到后执行），如果存在，把这个等待的fn杀了，重新开始一次等待。

            //setTimeout()方法的返回值是一个唯一的数值，这个数值有什么用呢？
            //如果你想要终止setTimeout()方法的执行，那就必须使用 clearTimeout()方法来终止，而使用这个方法的时候，系统必须知道你到底要终止的是哪一个setTimeout()方法
            //(因为你可能同时调用了好几个 setTimeout()方法)，这样clearTimeout()方法就需要一个参数，这个参数就是setTimeout()方法的返回值(数值)，用这个数值来唯一确定结束哪一个setTimeout()方法。
                }
                timeId = setTimeout(fn,delay);
                
            }
        }
        function showTop  () {
            var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        　　console.log('滚动条位置：' + scrollTop);
        }
        window.onscroll = debounce(showTop,1000)

        /*节流  为函数设定一个冷却时间**/
        //效果：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
        function coldDown(fn, delay){
            let colding = false;
            return function(fn, delay){
                if(!colding){
                    colding = true;
                    fn();
                    setTimeout(function(){colding = false},delay);
                }
            }
        }

        function showTop  () {
            var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        　　console.log('滚动条位置：' + scrollTop);
        }
        window.onscroll = debounce(showTop,1000)

    </script>
</html>